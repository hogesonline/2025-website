title: 'MicroPython: The best bits!'
start: 2024-11-23 14:10:00+11:00
end: 2024-11-23 14:40:00+11:00
room: eureka3
track:
abstract: "<p>MicroPython continues to grow in popularity. But <em>why</em>? What
  is it about this pint-sized version of Python that makes it so darn compelling?
  What are the best bits of MicroPython? </p>\n<p>Join me in this talk for a whirlwind
  tour of some of the most exciting features of this modern embedded programming language.</p>"
description: "<p>[Slides are now available: <a href=\"https://docs.google.com/presentation/d/e/2PACX-1vQDB-oMalkKqR1GNfWwSKGRDsSJGJQKIGu3GUbQWLuWMkMn3NOd9GjoYdhr6YLKU0U_9jtu5Q_xjyit/pub\"\
  >MicroPython: The Best Bits!</a>]</p>\n<p>There’s no question; C and C++ are the
  800 pound gorillas of the embedded domain. But MicroPython provides a high-level
  language alternative in this space and, in addition to modern syntax, it also provides
  unique features that can <em>vastly</em> improve the embedded development experience.
  Which - let’s be honest! - has <em>barely improved</em> in decades.</p>\n<p>So,
  let’s take a look at some of those features! </p>\n<p>For starters, there’s the
  live REPL. We’ll look at how to use the REPL and why having an immediate way to
  interact with your device is an indispensable tool. </p>\n<p>Python’s <code>asyncio</code>
  is well-supported in MicroPython and, it turns out, is a very good fit for embedded
  devices. We’ll look at what makes it such a good fit - and how we can apply libraries
  like <code>aioble</code> and <code>aiorepl</code> to accelerate development.</p>\n
  <p>To manage a connection to your MicroPython device, the core team provides the
  official tool, <code>mpremote</code>. We’ll cover some of the useful features it
  provides and explain how to integrate them into a workflow that allows rapid development.</p>\n
  <p>Although it’s a high-level language, MicroPython balances providing access to
  low-level features in an accessible way. We’ll briefly touch on using such features
  as the PIO, RMT, USBDevice and register access. From there we’ll shift to discuss
  some of the performance optimisation features such as inline assembly, frozen code
  and the viper and native emitters.</p>\n<p>To wrap up, we’ll look at how <em>freakin’
  useful</em> it is to be able to run MicroPython on x86 (and even in a browser!).</p>\n
  <p>There’s a lot to cover but these features can really help level-up embedded development!</p>"
code: HFXFLZ
speakers:
- N9ZZWG
cw:
